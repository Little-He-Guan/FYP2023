/**
 * @author Guanyuming He
 */
package edu.guanyfyp.format;

import edu.guanyfyp.SyntaxContext;
import edu.guanyfyp.generated.JavaLexer;

/**
 * A code block represents the format influence of a code token generated by a parser.
 * Here the type of the token will also be taken into consideration because
 * different code blocks fit into different format restrictions.
 */
public class CodeBlock extends FormatToken 
{
	
	public enum Type
	{
		// Unknown for now.
		// Perhaps unassigned.
		UNKNOWN,
		
		// Keywords
		// TODO: Perhaps divide keywords
		// into groups of finer granularity
		// that can reflect OOP and other programming styles.
		KEYWORD_UNCLASSIFIED,
		
		// Literals
		STRING_LITERAL,
		NUMBER_LITERAL,
		BOOL_LITERAL,
		NULL_LITERAL,
		
		// Punctuation
		SEMICOLON,
		COMMA,
		DOT,
		// Parentheses
		L_PARENTHESIS,
		R_PARENTHESIS,
		// square brackets
		L_SBRACKET,
		R_SBRACKET,
		// curly brackets
		L_CBRACKET,
		R_CBRACKET,
		
		// Identifiers
		// IDENTIFIER_UNCLASSIFIED is a token that is known to be an identifier at the lexer level,
		// but remains to be classified by the parser
		IDENTIFIER_UNCLASSIFIED,
		CLASS_NAME,
		INTERFACE_NAME,
		ENUM_NAME,
		CONSTRUCTOR_NAME,
		METHOD_NAME,
		// variable of some class
		FIELD_NAME,
		// variable of some function
		VARIABLE_NAME,
		
		// Operators
		OPERATOR_UNCLASSIFIED,
		
		// Others
		OTHERS,
	}
	
	// The type of the code token.
	// Not final because the information may not be available at creation.
	protected Type type;
	public Type getType() { return type; }
	public void setType(Type type) { this.type = type; }
	
	/**
	 * Assigns this CodeBlock a type based on what the lexer can tell me about it.
	 * @param tokenType
	 */
	public void setTypeFromLexerTokenType(int tokenType)
	{
		switch(tokenType)
		{
		// Keywords
		case JavaLexer.ABSTRACT:
		case JavaLexer.ASSERT:
		case JavaLexer.BOOLEAN:
		case JavaLexer.BREAK:
		case JavaLexer.BYTE:
		case JavaLexer.CASE:
		case JavaLexer.CATCH:
		case JavaLexer.CHAR:	
		case JavaLexer.CLASS:
		case JavaLexer.CONST:
		case JavaLexer.CONTINUE:
		case JavaLexer.DEFAULT:	
		case JavaLexer.DO:
		case JavaLexer.DOUBLE:
		case JavaLexer.ELSE:
		case JavaLexer.ENUM:	
		case JavaLexer.EXTENDS:
		case JavaLexer.FINAL:
		case JavaLexer.FINALLY:
		case JavaLexer.FLOAT:
		case JavaLexer.FOR:
		case JavaLexer.IF:
		case JavaLexer.GOTO:
		case JavaLexer.IMPLEMENTS:	
		case JavaLexer.IMPORT:
		case JavaLexer.INSTANCEOF:
		case JavaLexer.INT:
		case JavaLexer.INTERFACE:	
		case JavaLexer.LONG:
		case JavaLexer.NATIVE:
		case JavaLexer.NEW:
		case JavaLexer.PACKAGE:	
		case JavaLexer.PRIVATE:
		case JavaLexer.PROTECTED:
		case JavaLexer.PUBLIC:
		case JavaLexer.RETURN:
		case JavaLexer.SHORT:
		case JavaLexer.STATIC:
		case JavaLexer.STRICTFP:
		case JavaLexer.SUPER:	
		case JavaLexer.SWITCH:
		case JavaLexer.SYNCHRONIZED:
		case JavaLexer.THIS:
		case JavaLexer.THROW:	
		case JavaLexer.THROWS:
		case JavaLexer.TRANSIENT:
		case JavaLexer.TRY:
		case JavaLexer.VOID:	
		case JavaLexer.VOLATILE:
		case JavaLexer.WHILE:
		// Module-related keywords
		case JavaLexer.MODULE:
		case JavaLexer.OPEN:
		case JavaLexer.REQUIRES:
		case JavaLexer.EXPORTS:
		case JavaLexer.OPENS:
		case JavaLexer.TO:	
		case JavaLexer.USES:
		case JavaLexer.PROVIDES:
		case JavaLexer.WITH:
		case JavaLexer.TRANSITIVE:	
		// var
		case JavaLexer.VAR:
		// switch expressions (Java17)
		case JavaLexer.YIELD:
		// records
		case JavaLexer.RECORD:
		// Sealed classes
		case JavaLexer.SEALED:	
		case JavaLexer.PERMITS:
		case JavaLexer.NON_SEALED:
			this.type = Type.KEYWORD_UNCLASSIFIED;
			break;
		
		// Literals
		case JavaLexer.DECIMAL_LITERAL:
		case JavaLexer.HEX_LITERAL:
		case JavaLexer.OCT_LITERAL:
		case JavaLexer.BINARY_LITERAL:
		case JavaLexer.FLOAT_LITERAL:
		case JavaLexer.HEX_FLOAT_LITERAL:
			this.type = Type.NUMBER_LITERAL;
			break;
		case JavaLexer.CHAR_LITERAL:
		case JavaLexer.STRING_LITERAL:
		case JavaLexer.TEXT_BLOCK:
			this.type = Type.STRING_LITERAL;
			break;
		case JavaLexer.BOOL_LITERAL:
			this.type = Type.BOOL_LITERAL;
			break;
		case JavaLexer.NULL_LITERAL:
			this.type = Type.NULL_LITERAL;
			break;
			
		// Punctuation
		case JavaLexer.SEMI:
			this.type = Type.SEMICOLON;
			break;
		case JavaLexer.COMMA:
			this.type = Type.COMMA;
			break;
		case JavaLexer.DOT:
			this.type = Type.DOT;
			break;
		case JavaLexer.LPAREN:
			this.type = Type.L_PARENTHESIS;
			break;
		case JavaLexer.RPAREN:
			this.type = Type.R_PARENTHESIS;
			break;
		case JavaLexer.LBRACE:
			this.type = Type.L_CBRACKET;
			break;
		case JavaLexer.RBRACE:
			this.type = Type.R_CBRACKET;
			break;
		case JavaLexer.LBRACK:
			this.type = Type.L_SBRACKET;
			break;
		case JavaLexer.RBRACK:
			this.type = Type.R_SBRACKET;
			break;
		
		// Operators
		case JavaLexer.ASSIGN:
		// Comparisons
		case JavaLexer.GT:
		case JavaLexer.LT:
		case JavaLexer.EQUAL:	
		case JavaLexer.LE:
		case JavaLexer.GE:
		case JavaLexer.NOTEQUAL:
		// ...
		case JavaLexer.BANG:
		case JavaLexer.TILDE:
		case JavaLexer.QUESTION:
		case JavaLexer.COLON:
		// Logical
		case JavaLexer.AND:	
		case JavaLexer.OR:
		// Math
		case JavaLexer.INC:
		case JavaLexer.DEC:
		case JavaLexer.ADD:	
		case JavaLexer.SUB:
		case JavaLexer.MUL:
		case JavaLexer.DIV:
		case JavaLexer.BITAND:
		case JavaLexer.BITOR:
		case JavaLexer.CARET:
		case JavaLexer.MOD:
		// Op-assign
		case JavaLexer.ADD_ASSIGN:	
		case JavaLexer.SUB_ASSIGN:
		case JavaLexer.MUL_ASSIGN:
		case JavaLexer.DIV_ASSIGN:
		case JavaLexer.AND_ASSIGN:	
		case JavaLexer.OR_ASSIGN:
		case JavaLexer.XOR_ASSIGN:
		case JavaLexer.LSHIFT_ASSIGN:
		case JavaLexer.RSHIFT_ASSIGN:	
		case JavaLexer.URSHIFT_ASSIGN:
		case JavaLexer.MOD_ASSIGN:
			this.type = Type.OPERATOR_UNCLASSIFIED;
			break;
			
		// Identifier
		case JavaLexer.IDENTIFIER:
			this.type = Type.IDENTIFIER_UNCLASSIFIED;
			break;
			
		// Misc
		case JavaLexer.ARROW:	
		case JavaLexer.COLONCOLON:
		case JavaLexer.AT:
		case JavaLexer.ELLIPSIS:
			this.type = Type.OTHERS;
			break;
			
		default:
			// Should never reach here because I should have handled all types
			assert false;
		}
	}

	/**
	 * The constructor that assigns type when the info is available
	 * @param characters
	 * @param position
	 * @param act_pos
	 * @param line
	 * @param index_in_line
	 * @param type
	 */
	public CodeBlock
	(
		String characters, 
		int position, int act_pos, 
		int line, int index_in_line,
		Type type
	) 
	{
		super
		(
			characters, position, act_pos, line, index_in_line
		);	
		this.type = type;
	}
	
	/**
	 * The constructor that should be used when the type is unavailable.
	 * @param characters
	 * @param position
	 * @param act_pos
	 * @param line
	 * @param index_in_line
	 */
	public CodeBlock
	(
		String characters, 
		int position, int act_pos, 
		int line, int index_in_line
	) 
	{
		super
		(
			characters, position, act_pos, line, index_in_line
		);	
		this.type = Type.UNKNOWN;
	}

	@Override
	protected float calculate_format_score(SyntaxContext ctx)
	{
		throw new RuntimeException("Not implemented.");		
	}
}
